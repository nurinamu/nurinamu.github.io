---
title : Functional Programming에서 Monad가 필요한 이유에 대한 단상
layout : default
category : dev
description : 꿈속에서 갑자기 이게 아닐까 하고 깨달은 Monad의 필요성에 대하여 적어본다.
---

### 나에게 Monad란?
Function Programming을 공부하면서 듣게되는 Monad는 언제나 넘사벽의 러닝커브라는 수식어와 함께 학습두려움의 대상이다. 그럼에도 불구하고 뭐랄까 정복하고 싶은 학습목표가 되기도 한다. 나에게 Monad는 FP를 공부하면서 아무리 들어도 뭔가 이게 뭐지? 왜 필요하지? 를 끊임없이 반문해도 알 수 없는 의문 덩어리이다. 일단 내가 알고 있는 수준으로의 Monad를 정의 해보자.

나에게 Monad란 
- instance화 되지 않은, 아직 evaluate 되지 않은 추상 객체
- 함수형으로 타입 추상화가 가능한 추상 객체

결국 추상,추상 실체가 없는 뜬구름.

정말 뜬구름 잡는 것 같았다.

### Eureka!!
2019년 목표로 일주일에 글 하나는 써야한다는 목표와 연초부터 밀려오는 업무 일정속에 어떻게든 글 쓸거리를 찾아야지하는 무의식이 결합되어 결국 새벽 퇴근 후 게임하다 아침에 살짝 잠든 그... 찰나에 꿈 속에서 지난번 글에서 작성한 함수 파라메타 예제 코드가 떠올랐다.

함수형 프로그래밍의 장점 중의 하나는 함수 끼리의 의존성이 없고 함수 수정시 다른 함수에 Side Effect가 없다는 것이다. 그런데 지난번에 작성했던 코드를 다시 보자.

```kotlin
fun f(x: (Int) -> Int) : (Int) -> Int = { x(it) + 1 }

fun xfunc(z: Int) = 2 * z

fun main(args: Array<String>) {
    println(f(::xfunc)(2)) //5
}
```

만약에 내가 xfunc에게 파라메타를 하나 추가 하고 싶다고 생각해보자 어떤 일이 일어날까?

```kotlin
fun f(x: (Int) -> Int) : (Int) -> Int = { x(it) + 1 }

fun xfunc(z: Int, n: Int) = 2 * z * n //n 추가

fun main(args: Array<String>) {
    println(f(::xfunc)(2)) //ERROR
}
```

`main`함수에서 사용하는 `f`함수의 인자인 `xfunc`는 더 이상 valid하지 않다. `xfunc`를 수정함으로 인해 `main`함수와 `f`함수를 수정해야하는 상황이 온 것이다. **Side effect**가 생긴 것이다.

-- 해당 내용을 실제 적용위해 코드 작성해보았지만 실패.
이 내용은 drop